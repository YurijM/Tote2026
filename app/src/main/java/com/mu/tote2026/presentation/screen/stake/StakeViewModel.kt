package com.mu.tote2026.presentation.screen.stake

import android.os.Build
import androidx.annotation.RequiresApi
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import androidx.navigation.toRoute
import com.mu.tote2026.data.repository.Result.DEFEAT
import com.mu.tote2026.data.repository.Result.DRAW
import com.mu.tote2026.data.repository.Result.WIN
import com.mu.tote2026.domain.model.GamblerModel
import com.mu.tote2026.domain.model.GameModel
import com.mu.tote2026.domain.model.StakeModel
import com.mu.tote2026.domain.usecase.gambler_usecase.GamblerUseCase
import com.mu.tote2026.domain.usecase.game_usecase.GameUseCase
import com.mu.tote2026.presentation.navigation.Destinations.StakeDestination
import com.mu.tote2026.presentation.utils.Errors.ADD_GOAL_INCORRECT
import com.mu.tote2026.presentation.utils.GROUPS_COUNT
import com.mu.tote2026.presentation.utils.START
import com.mu.tote2026.presentation.utils.checkIsFieldEmpty
import com.mu.tote2026.presentation.utils.generateResult
import com.mu.tote2026.ui.common.UiState
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import javax.inject.Inject

@RequiresApi(Build.VERSION_CODES.O)
@HiltViewModel
class StakeViewModel @Inject constructor(
    savedStateHandle: SavedStateHandle,
    private val gameUseCase: GameUseCase,
    gamblerUseCase: GamblerUseCase
) : ViewModel() {
    private val _state = MutableStateFlow(StakeState())
    val state = _state.asStateFlow()

    var game by mutableStateOf(GameModel())
        private set
    var stake by mutableStateOf(StakeModel())
        private set
    private var oldStake = StakeModel()
    private var gamblers: List<GamblerModel> by mutableStateOf(listOf())
    var teamGames by mutableStateOf(listOf<GameModel>())
        private set
    var canGenerated by mutableStateOf(false)
        private set

    var exit by mutableStateOf(false)
        private set

    var isExtraTime = false
        private set
    var isByPenalty = false
        private set

    private var errorGoal1 = ""
    private var errorGoal2 = ""
    private var errorAddGoal1 = ""
    private var errorAddGoal2 = ""

    var errorMainTime = ""
        private set
    var errorExtraTime = ""
        private set
    var errorByPenalty = ""
        private set

    var generatedStake = mutableStateOf("")
        private set

    var enabled = false
        private set

    init {
        gamblerUseCase.getGamblerList().onEach { gamblerState ->
            if (gamblerState is UiState.Success) {
                gamblers = gamblerState.data

                val formatter = DateTimeFormatter.ofPattern("dd.MM.y")
                val dt = LocalDate.parse(START, formatter)
                canGenerated = LocalDateTime.now().toLocalDate() < dt.minusDays(10)

                val args = savedStateHandle.toRoute<StakeDestination>()
                gameUseCase.getGamblerGameStake(args.gameId, args.gamblerId).onEach { gameState ->
                    _state.value = StakeState(gameState)

                    if (gameState is UiState.Success) {
                        game = gameState.data

                        stake = if (game.stakes.isNotEmpty())
                            game.stakes[0]
                        else {
                            val gambler = gamblers.find { it.id == args.gamblerId }
                            StakeModel(
                                gameId = args.gameId,
                                gamblerId = args.gamblerId,
                                gamblerNickname = gambler?.nickname ?: "",
                                gamblerRatePercent = gambler?.ratePercent ?: 0.0
                            )
                        }

                        oldStake = stake

                        enabled = checkValues()

                        gameUseCase.getGameList().onEach { gameListState ->
                            if (gameListState is UiState.Success) {
                                teamGames = gameListState.data
                                    .filter {
                                        (it.team1 in listOf(game.team1, game.team2) || it.team2 in listOf(game.team1, game.team2))
                                                && it.start.toLong() < System.currentTimeMillis()
                                                && it.id != game.id
                                    }
                                    .sortedWith(
                                        compareBy<GameModel> { it.team1 == game.team2 || it.team2 == game.team2 }
                                            .thenBy { it.team1 == game.team1 || it.team2 == game.team1 }
                                    )
                            }
                        }.launchIn(viewModelScope)
                    }
                }.launchIn(viewModelScope)
            }
        }.launchIn(viewModelScope)
    }

    fun onEvent(event: StakeEvent) {
        when (event) {
            is StakeEvent.OnGoalChange -> {
                checkGoal(
                    extraTime = event.extraTime,
                    teamNo = event.teamNo,
                    goal = event.goal
                )
                enabled = checkValues()
            }

            is StakeEvent.OnByPenaltyChange -> {
                stake = stake.copy(byPenalty = event.team)
                enabled = checkValues()
            }

            is StakeEvent.OnSave -> {
                gameUseCase.saveStake(oldStake, stake).onEach { saveStakeState ->
                    _state.value = when (saveStakeState) {
                        is UiState.Success -> {
                            var winCount = game.winCount
                            var drawCount = game.drawCount
                            var defeatCount = game.defeatCount

                            if (oldStake.result != stake.result) {
                                when (oldStake.result) {
                                    WIN -> winCount--
                                    DRAW -> drawCount--
                                    DEFEAT -> defeatCount--
                                }
                                when (stake.result) {
                                    WIN -> winCount++
                                    DRAW -> drawCount++
                                    DEFEAT -> defeatCount++
                                }
                            }
                            val allCount = winCount + drawCount + defeatCount

                            gameUseCase.getGame(game.id).onEach { gameState ->
                                if (gameState is UiState.Success) {
                                    game = gameState.data
                                    game = game.copy(
                                        winCount = winCount,
                                        drawCount = drawCount,
                                        defeatCount = defeatCount,
                                        winCoefficient = if (winCount != 0) {
                                            allCount.toDouble() / winCount.toDouble()
                                        } else 0.0,
                                        drawCoefficient = if (drawCount != 0) {
                                            allCount.toDouble() / drawCount.toDouble()
                                        } else 0.0,
                                        defeatCoefficient = if (defeatCount != 0) {
                                            allCount.toDouble() / defeatCount.toDouble()
                                        } else 0.0,
                                    )
                                    gameUseCase.saveGame(game).launchIn(viewModelScope)
                                }
                            }.launchIn(viewModelScope)

                            exit = true
                            StakeState(UiState.Success(game))
                        }

                        is UiState.Loading -> StakeState(UiState.Loading)
                        is UiState.Error -> StakeState(UiState.Error(saveStakeState.error))
                        else -> StakeState(UiState.Default)
                    }
                }.launchIn(viewModelScope)
            }

            is StakeEvent.OnGenerateStake -> {
                generatedStake.value = generateResult()
            }
        }
    }

    private fun checkGoal(extraTime: Boolean, teamNo: Int, goal: String) {
        if (!extraTime) {
            if (teamNo == 1) {
                stake = stake.copy(goal1 = goal)
                errorGoal1 = checkIsFieldEmpty(goal)
            } else {
                stake = stake.copy(goal2 = goal)
                errorGoal2 = checkIsFieldEmpty(goal)
            }
            errorMainTime = errorGoal1.ifBlank { errorGoal2 }
        } else {
            if (teamNo == 1) {
                stake = stake.copy(addGoal1 = goal)
                errorAddGoal1 = checkIsFieldEmpty(goal).ifBlank {
                    if (stake.addGoal1 < stake.goal1)
                        ADD_GOAL_INCORRECT
                    else ""
                }
            } else {
                stake = stake.copy(addGoal2 = goal)
                errorAddGoal2 = checkIsFieldEmpty(goal).ifBlank {
                    if (stake.addGoal2 < stake.goal2)
                        ADD_GOAL_INCORRECT
                    else ""
                }
            }
            errorExtraTime = errorAddGoal1.ifBlank { errorAddGoal2 }
        }

        setResult(stake.goal1, stake.goal2, extraTime)
    }

    private fun setResult(goal1: String, goal2: String, extraTime: Boolean) {
        val result = if (goal1.isNotBlank() && goal2.isNotBlank()) {
            when {
                goal1.toInt() > goal2.toInt() -> WIN
                goal1.toInt() == goal2.toInt() -> DRAW
                else -> DEFEAT
            }
        } else ""

        stake = if (!extraTime) {
            stake.copy(result = result)
        } else {
            stake.copy(addResult = "")
        }
    }

    private fun checkMainTime(): Boolean =
        if (stake.goal1.isNotBlank()
            && stake.goal2.isNotBlank()
        ) {
            isExtraTime = (game.groupId.isNotBlank()
                    && game.groupId.toInt() > GROUPS_COUNT
                    && stake.goal1 == stake.goal2)
            if (!isExtraTime) {
                stake = stake.copy(
                    addGoal1 = "",
                    addGoal2 = "",
                    byPenalty = "",
                )
            }
            true
        } else {
            false
        }

    private fun checkExtraTime(): Boolean {
        var result = (stake.addGoal1.isNotBlank() && (stake.addGoal1 >= stake.goal1))
        result = (result && (stake.addGoal2.isNotBlank()) && (stake.addGoal2 >= stake.goal2))

        isByPenalty = result && (stake.addGoal1 == stake.addGoal2)

        if (isByPenalty) {
            result = stake.byPenalty.isNotBlank()
        } else {
            stake = stake.copy(byPenalty = "")
        }

        return result
    }

    private fun checkValues(): Boolean {
        isExtraTime = false
        isByPenalty = false

        var result = checkMainTime()

        if (isExtraTime) {
            result = result && checkExtraTime()
        }

        return result
    }

    data class StakeState(
        val result: UiState<GameModel> = UiState.Default
    )
}